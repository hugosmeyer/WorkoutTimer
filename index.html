async function runScript() {
  const lines = scriptBox.value.trim().split("\n").map(line => line.trim());
  const commandTree = parseCommands(lines);
  const flatCommands = flattenCommands(commandTree);
  await executeCommands(flatCommands);
  progressBar.value = 1;
}

function parseCommands(lines) {
  const root = [];
  const stack = [{ commands: root }];

  for (let line of lines) {
    if (line === "") continue;
    const current = stack[stack.length - 1].commands;

    if (line.startsWith("loop:")) {
      const newBlock = [];
      const loopCmd = { type: "loop", commands: newBlock, repeat: 1 };
      current.push(loopCmd);
      stack.push(loopCmd);  // push the loop itself
    } else if (line.startsWith("repeat:")) {
      const repeat = parseInt(line.slice(7).trim()) || 1;
      const lastLoop = stack.pop();
      if (lastLoop && lastLoop.type === "loop") {
        lastLoop.repeat = repeat;
      } else {
        console.error("repeat without matching loop");
      }
    } else if (line.startsWith("say:")) {
      current.push({ type: "say", text: line.slice(4).trim() });
    } else if (line.startsWith("wait:")) {
      current.push({ type: "wait", seconds: parseFloat(line.slice(5).trim()) });
    }
  }

  return root;
}




function flattenCommands(tree) {
  const result = [];

  function expand(commands) {
    for (let cmd of commands) {
      if (cmd.type === "loop") {
        for (let i = 0; i < cmd.repeat; i++) {
          expand(cmd.commands);
        }
      } else {
        result.push(cmd);
      }
    }
  }

  expand(tree);
  return result;
}

async function executeCommands(commands) {
  for (let i = 0; i < commands.length; i++) {
    const cmd = commands[i];
    progressBar.value = i / commands.length;

    if (cmd.type === "say") {
      const u = new SpeechSynthesisUtterance(cmd.text);
      u.lang = 'en-US';
      u.voice = speechSynthesis.getVoices().find(v => v.lang === 'en-US');
      await new Promise(r => {
        u.onend = r;
        speechSynthesis.speak(u);
      });
    } else if (cmd.type === "wait") {
      await new Promise(r => setTimeout(r, cmd.seconds * 1000));
    }
  }
}
